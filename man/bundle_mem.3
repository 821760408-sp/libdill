.\" Automatically generated by Pandoc 1.19.2.1
.\"
.TH "BUNDLE_MEM" "3" "" "libdill" "libdill Library Functions"
.hy
.SH NAME
.PP
bundle_mem \- create an empty coroutine bundle
.SH SYNOPSIS
.IP
.nf
\f[C]
#include\ <libdill.h>

int\ bundle_mem(void*\ mem);
\f[]
.fi
.SH DESCRIPTION
.PP
Coroutines are always running in bundles.
Even a single coroutinecreated by \f[B]go\f[] gets its own bundle.
A bundle is a lifetimecontrol mechanism.
When it is closed, all coroutines within thebundle are canceled.
.PP
This function creates an empty bundle.
Coroutines can be added tothe bundle using the \f[B]bundle_go\f[] and
\f[B]bundle_go_mem\f[] functions.
.PP
If \f[B]hdone\f[] is called on a bundle, it waits until all
coroutinesexit.
After calling \f[B]hdone\f[], irrespective of whether it succeedsor
times out, no further coroutines can be launched using thebundle.
.PP
When \f[B]hclose()\f[] is called on the bundle, all the
coroutinescontained in the bundle will be canceled.
In other words, all theblocking functions within the coroutine will
start failing with an\f[B]ECANCELED\f[] error.
The \f[B]hclose()\f[] function itself won\[aq]t exituntil all the
coroutines in the bundle exit.
.PP
This function allows to avoid one dynamic memory allocation bystoring
the object in user\-supplied memory.
Unless you arehyper\-optimizing use \f[B]bundle\f[] instead.
.PP
\f[B]mem\f[]: The memory to store the newly created object.
It must be at least \f[B]BUNDLE_SIZE\f[] bytes long and must not be
deallocated before the object is closed.
.SH RETURN VALUE
.PP
In case of success the function returns handle of the newly create
coroutine bundle.
In case of error it returns \-1 and sets \f[B]errno\f[] to one of the
values below.
.SH ERRORS
.IP \[bu] 2
\f[B]EMFILE\f[]: The maximum number of file descriptors in the process
are already open.
.IP \[bu] 2
\f[B]ENFILE\f[]: The maximum number of file descriptors in the system
are already open.
.IP \[bu] 2
\f[B]ENOMEM\f[]: Not enough memory.
.SH EXAMPLE
.IP
.nf
\f[C]
int\ b\ =\ bundle();
bundle_go(b,\ worker());
bundle_go(b,\ worker());
bundle_go(b,\ worker());
msleep(now()\ +\ 1000);
/*\ Cancel\ any\ workers\ that\ are\ still\ running.\ */
hclose(b);
\f[]
.fi
.SH SEE ALSO
.PP
\f[B]bundle\f[](3) \f[B]bundle_go\f[](3) \f[B]bundle_go_mem\f[](3)
\f[B]go\f[](3) \f[B]go_mem\f[](3) \f[B]hclose\f[](3) \f[B]yield\f[](3)
